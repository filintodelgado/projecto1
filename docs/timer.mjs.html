<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: timer.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: timer.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Implements the Timer.
 * 
 * @module cinescape/timer
 */

import { EventModel } from "./eventModel.mjs";

/**
 * Generic Timer that allows to define a time to counter up to
 * and define callbacks for specific moments in the time.
 * 
 * Allows operantions like pause, resume and stop and define event
 * listeners for those operations.
 * 
 */
export 
class Timer
extends EventModel {
  /**
   * A integer number that represent the time in seconds
   * @typedef {Number} Seconds
   */

  /**
   * A integer number that represent the time in miliseconds
   * @typedef {Number} Miliseconds
   */

  static #minTime = 0;

  /**
   * The minimun time for every {@link Timer}.
  */
  static get minTime() { return this.#minTime }

  /** 
   * The minimun stop time will always be {@link minTime} + 1.
   */
  static get minStopTime() { return Timer.minTime + 1 }

  #stopTime = Timer.minStopTime;
  /**
   * The time in which the timer should stop
   * 
   * by default 
   */
  get stopTime() { return this.#stopTime };
  set stopTime(value) {
    // the stop will be always be at least 
    // be 1 more than the minTime
    value = Math.max(value, Timer.minStopTime);

    this.#stopTime = value;
  }

  #time = 0;
  /** 
   * The current time in seconds.
   * 
   * Can be set but will never be less than {@link Timer.minTime}
   * 
   * @type {Seconds}
   */
  get time() { return this.#time };
  set time(value) { 
    // the time should never be less than 0 (less then the minimun)
    value = Math.max(
      // garantee that it will never be greater than the stop
      Math.min(value, this.stopTime),
      Timer.#minTime
    )

    // the values should only be integer
    value = Math.floor(value);

    this.#time = value;
  }

  #step = 1;
  /** 
   * How much the time should be incremented each second. 
   * 
   * Default is 1 second.
   * 
   * @type {Seconds}.
   */
  get step() { return this.#step };
  set step(value) {
    value = parseInt(value);
    
    if(!value) value = 1;

    this.#step = value;
  }
  
  /**
   * How fast in ms the timer will be refreshed.
   * 
   * Default is 1000 miliseconds or 1 second.
   * 
   * @type {Miliseconds}.
   */
  speed = 1000;

  #paused = false;
  get paused() { return this.#paused };
  set paused(value) {
    if(typeof(value) != "boolean"
    || value == this.#paused) return;

    // call methods instead of modifiying the value
    if(value) this.pause();
    else this.resume();
  }

  /**
   * Says if the timer is running.
   * 
   * Always inverse of {@link paused}.
   */
  get running() { return !this.paused };

  /**
   * Increments the time.
   * 
   * @param {Seconds} increment How much should the time be incremented.
   * If no value is provided it will be incremented by the {@link step} 
   * that is 1 by default.
   * 
   * Decrements if the value is negative.
   */
  increment(increment=null) {
    // make sure it is a number
    // if it is not defined set the increment to the step
    increment = increment ? parseInt(increment) : this.step;
    this.time = this.time + increment;
  }

  /**
   * 
   * @param {Seconds} decrement How much should the time be decremented.
   * 
   * If no value is provided it will be incremented by the {@link step} 
   * that is 1 by default.
   * 
   * Increments if the value negative.
   */
  decrement(decrement=null) {
    decrement = decrement ? parseInt(decrement) : this.step;

    // unecessary to decrement manually
    // just use the incremenet with a inverted value
    this.increment(-decrement)
  }

  /**
   * The function that will execute each step.
   * 
   * It does not trigger the step event. This event is trigged by
   * {@link _task} method so that the event is only trigged when
   * the timer is not paused.
   */
  _runner() {
    // only run the taks if not paused
    if(this.running) this._task();

    // stop on timeout
    if(this.time == this.stopTime)
      this.stop();

    // the timeout will always be set
    setTimeout(
      // bind so that the value of this stays the same
      this._runner.bind(this),
      this.speed
    )
  }

  /**
   * The tasks the timer will make if it is not paused.
   * 
   * Things like:
   * 1. Increment the timer;
   * 1. Trigger Events;
   */
  _task() {
    this.increment();
    this.runBreakingPointCallbacks(this.time);
    this.dispatchEvent("step");
  }

  /**
   * Will start the timer if it is not already started.
   * 
   * @returns {Boolean} 
   */
  start() {
    // only execute if timer is not running
    if(!this.running) return false;

    this.dispatchEvent("start");
    this._runner();

    return true;
  }

  /**
   * Pauses the timer execution.
   * 
   * @returns 
   */
  pause() {
    if(this.paused)
      return false;

    this.dispatchEvent("pause");
    this.#paused = true;

    return true;
  }

  /**
   * 
   * @param {Boolean} pause 
   */
  reset() {
    // set the time to the minimum
    this.time = Timer.#minTime;
  }

  stop() {
    this.reset();

    // set pause without triggering the event
    this.#paused = true;
    this.dispatchEvent("stop");
  }

  /**
   * The type of the callback called by a breaking point.
   * 
   * @typedef {(this: Timer, timer: Timer) => void} BreakingPointCallback
   */
  
  /**
   * The breaking points callbacks are stored in this object
   * were the key are the time assigned and the value is a 
   * array with the callbacks;
   * 
   * @type {{ [key: number]: Array&lt;BreakingPointCallback> }}
   */
  #breakingPoints = {};

  /**
   * Says if the value is in range of the Timer
   * 
   * @param {Seconds} time 
   * @returns {Boolean}
   */
  _inRange(time) {
    // not a valid integer
    if(!(time = parseInt(time))) return false;

    if(time &lt; Timer.minTime || time > this.stopTime)
      return false;

    return true;
  }

  /**
   * Says if a breaking point array already exists
   * 
   * @param {*} time 
   */
  _isBreakingPointArray(time) {
    if(this.#breakingPoints[time] instanceof Array)
      return true;
    
    return false;
  }
  
  /**
   * Says if there is a breaking point callback defined for
   * the expecific time
   * 
   * @param {Seconds} time 
   */
  _isBreakingPointCallback(time) {
    return this.#breakingPoints[time] ? true : false;
  }

  /**
   * Creates a new breaking point array or return the existing one.
   * 
   * @param {Second} time 
   * @returns {[BreakingPointCallback]}  The new breaking point array if assigned or
   * the breaking point array already defined.
   */
  _createBreakingPointArray(time) {
    let breakingPoint = this.#breakingPoints[time]

    // only creates if it is not already created
    if(!breakingPoint) {
      this.#breakingPoints[time] = [];
      breakingPoint = this.#breakingPoints[time]
    }

    return breakingPoint;
  }

  /**
   * Allows to add a callback to a specific time in the Timer.
   * 
   * @param {Seconds} time
   * @param {BreakingPointCallback} callback
   */
  addBreakingPoint(time, callback) {
    if(!this._inRange(time)) return false;

    const breakingPointArray = this._createBreakingPointArray(time);
    breakingPointArray.push(callback);

    return true;
  }

  removeBreakingPoint(time, callback) {
    if(!this._inRange(time)
    || !this._isBreakingPointArray(time)) 
      return false;
    
    let index;

    // remove all ocurances
    while((index = this.#breakingPoints[time].indexOf(callback)) != -1) {
      this.#breakingPoints[time].splice(index, 1)
    }

    return true
  }

  /**
   * Runs all breaking points callbacks in a specific time
   * 
   * @param {Seconds} time 
   */
  runBreakingPointCallbacks(time) {
    // ignore if there is no callback defined
    if(!this._isBreakingPointArray(time)
    || !this._isBreakingPointCallback(time))
      return;

    for(const callback of this.#breakingPoints[time])
      // binds the this and sets the first argument to this
      callback.bind(this)(this)
  }

  constructor(stop, autostart, step=null) {
    super();

    this.stopTime = stop;

    if(autostart) this.start();
    if(step) this.step = step;
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">CineScape</a></h2><h3>Modules</h3><ul><li><a href="module-cinescape.html">cinescape</a></li><li><a href="module-cinescape_eventModel.html">cinescape/eventModel</a></li><li><a href="module-cinescape_puzzle.html">cinescape/puzzle</a></li><li><a href="module-cinescape_timer.html">cinescape/timer</a></li></ul><h3>Classes</h3><ul><li><a href="module-cinescape_eventModel.EventModel.html">EventModel</a></li><li><a href="module-cinescape_puzzle.Puzzle.html">Puzzle</a></li><li><a href="module-cinescape_puzzle.PuzzleChoose.html">PuzzleChoose</a></li><li><a href="module-cinescape_puzzle.PuzzleSelect.html">PuzzleSelect</a></li><li><a href="module-cinescape_timer.Timer.html">Timer</a></li></ul><h3>Events</h3><ul><li><a href="module-cinescape_puzzle.html#~event:MissEvent">MissEvent</a></li><li><a href="module-cinescape_puzzle.html#~event:SolveEvent">SolveEvent</a></li><li><a href="module-cinescape_puzzle.html#~event:UnsolveEvent">UnsolveEvent</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon May 29 2023 22:58:35 GMT+0100 (Western European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
